<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Week 11: Numerical Methods</title>

	<link rel="stylesheet" href="/dist/reveal.css">
	<link rel="stylesheet" href="/dist/theme/black.css" id="theme">
	<link rel="stylesheet" href="/plugin/highlight/matlab.css">
	<link rel="stylesheet" href="/dist/week1.css">
	<link rel="stylesheet" href="/dist/site.css">
	<link rel="stylesheet" href="https://unpkg.com/keyboard-css@1.2.4/dist/css/main.min.css"/>
</head>
<body>
<div class="reveal">
	<div class="slides">


		<section data-markdown>
        <textarea data-template>
			# Week 11: Numerical Methods

			## Objectives:
			* Introduction to numerical methods üî¢.
			* Solving equations, integration, and differentiation ‚öôÔ∏è.
			* Differential equations and numerical solutions üìâ.

			--

			## Topics Covered:
			* Introduction to Numerical Methods üîç
			* Solving Equations üßÆ
			* Numerical Integration and Differentiation üìä
			* Differential Equations and Numerical Solutions üìà
		</textarea>
		</section>
		<section data-markdown>
        <textarea data-template>
			## Introduction to Numerical Methods üîç
			### What are Numerical Methods?
			Numerical methods are techniques to approximate solutions for mathematical problems that cannot be solved analytically.
			### Applications:
			Used in various fields including engineering, physics, finance, and more.
			### Importance of Numerical Methods:
			Many real-world problems involve complex equations that cannot be solved exactly.
			Approximation: Numerical methods provide approximate solutions that are often sufficient for practical purposes.
		</textarea>
		</section>
		<section data-markdown>
        <textarea data-template>
			## Solving Equations üßÆ
			### Root-Finding Methods:
			#### Bisection Method:
			Concept: Iteratively narrow down the interval where the root lies.
			#### Algorithm:
			1. Choose an interval [a,b] such that f(a) and f(b) have opposite signs.
			1. Compute the midpoint	a+b/2
			1. If f(c)=0, then c is the root. Otherwise, choose the subinterval [a,c] or [c,b] where the sign change occurs.
			1. Repeat until the interval is sufficiently small.

			--

			#### Newton-Raphson Method:
			Concept: Uses tangents to approximate the root.
			#### Algorithm:
			1. Start with an initial guess x0
			1. Update the guess using xn+1
			1. Repeat until convergence.

			--

			### Example Code (Newton-Raphson Method):

			```matlab
			Copy code
			f = @(x) x^2 - 4;       % Define the function
			df = @(x) 2*x;          % Define the derivative

			x0 = 1;                 % Initial guess
			tol = 1e-6;             % Tolerance
			maxIter = 100;          % Maximum number of iterations

			for iter = 1:maxIter
				x1 = x0 - f(x0)/df(x0);
				if abs(x1 - x0) < tol
					break;
				end
				x0 = x1;
			end

			disp(['Root: ', num2str(x1)]);
			```
		</textarea>
		</section>
		<section data-markdown>
        <textarea data-template>
			## Numerical Integration and Differentiation üìä
			### Numerical Integration:
			#### Trapezoidal Rule:

			Approximates the area under a curve as a series of trapezoids.
			#### Formula:
			\int_a^b f(x) \, dx \approx \frac{b - a}{2} \left[ f(a) + f(b) \right]

			#### Example Code:

			```matlab
			f = @(x) x^2;
			a = 0;
			b = 1;
			n = 100;  % Number of subintervals
			x = linspace(a, b, n+1);
			y = f(x);
			I = trapz(x, y);
			disp(['Integral: ', num2str(I)]);
			```

			#### Simpson‚Äôs Rule:
			Uses parabolic segments to approximate the area under a curve.

			#### Formula:
			\int_a^b f(x) \, dx \approx \frac{b - a}{6} \left[ f(a) + 4f\left(\frac{a+b}{2}\right) + f(b) \right]

			--

			### Numerical Differentiation:
			#### Finite Difference Method:

			* Forward Difference:
			f'(x) \approx \frac{f(x+h) - f(x)}{h}

			* Central Difference:
			f'(x) \approx \frac{f(x+h) - f(x-h)}{2h}

			#### Example Code:

			```matlab
			f = @(x) x^2;
			h = 1e-5;
			x = 1;
			forward_diff = (f(x+h) - f(x)) / h;
			central_diff = (f(x+h) - f(x-h)) / (2*h);
			disp(['Forward Difference: ', num2str(forward_diff)]);
			disp(['Central Difference: ', num2str(central_diff)]);
			```
		</textarea>
		</section>
		<section data-markdown>
        <textarea data-template>
			## Differential Equations and Numerical Solutions üìà
			### Ordinary Differential Equations (ODEs):
			#### Euler‚Äôs Method:
			Approximates solutions by stepping forward in small increments.

			#### Algorithm:
			Start with initial condition
			\y(t_0) = y_0

			Update using
			\y_{n+1} = y_n + h \cdot f(t_n, y_n), where h is the step size.

			--

			Example Code (Euler‚Äôs Method):

			```matlab
			f = @(t, y) -2*y;  % Define the differential equation
			t0 = 0;            % Initial time
			y0 = 1;            % Initial value
			h = 0.1;           % Step size
			t_final = 2;       % Final time

			t = t0:h:t_final;
			y = zeros(size(t));
			y(1) = y0;

			for n = 1:length(t)-1
				y(n+1) = y(n) + h*f(t(n), y(n));
			end

			plot(t, y);
			xlabel('Time t');
			ylabel('Solution y');
			title('Euler‚Äôs Method');
			```

			--

			### Runge-Kutta Methods:
			Provides higher accuracy by considering intermediate points.
			Algorithm: Runge-Kutta 4th order (RK4) is commonly used.

			1. Compute the first intermediate slope \k_1:

			$k_1 = h \cdot f(t_n, y_n)$

			2. Compute the second intermediate slope $k_2$:

			$k_2 = h \cdot f\left(t_n + \frac{h}{2}, y_n + \frac{k_1}{2}\right)$

			3. Compute the third intermediate slope $k_3$:

			$k_3 = h \cdot f\left(t_n + \frac{h}{2}, y_n + \frac{k_2}{2}\right)$

			4. Compute the fourth intermediate slope $k4$:

			$k_4 = h \cdot f(t_n + h, y_n + k_3)$

			5. Update the solution $y_n+1$ using the weighted average of these slopes:

			$y_{n+1} = y_n + \frac{k_1 + 2k_2 + 2k_3 + k_4}{6}$

			--

			#### Example Code (Runge-Kutta Method):
			``` matlab
			f = @(t, y) -2*y;  % Define the differential equation
			t0 = 0;            % Initial time
			y0 = 1;            % Initial value
			h = 0.1;           % Step size
			t_final = 2;       % Final time

			t = t0:h:t_final;
			y = zeros(size(t));
			y(1) = y0;

			for n = 1:length(t)-1
				k1 = h*f(t(n), y(n));
				k2 = h*f(t(n) + h/2, y(n) + k1/2);
				k3 = h*f(t(n) + h/2, y(n) + k2/2);
				k4 = h*f(t(n) + h, y(n) + k3);
				y(n+1) = y(n) + (k1 + 2*k2 + 2*k3 + k4) / 6;
			end

			plot(t, y);
			xlabel('Time t');
			ylabel('Solution y');
			title('Runge-Kutta Method');
			```
		</textarea>
		</section>
		<section data-markdown>
        <textarea data-template>
			Key Takeaways üéì
			Numerical methods are essential for approximating solutions to complex mathematical problems.
			Different methods are suited for different types of problems (e.g., root-finding, integration, differential equations).
			Understanding the underlying algorithms helps in selecting and applying the right method for a given problem.
			Homework üìù
			Root-Finding Methods:
			Implement the Bisection and Newton-Raphson methods to find the roots of a given function.
			Numerical Integration:
			Use the Trapezoidal and Simpson‚Äôs rules to approximate the integral of a given function.
			Differential Equations:
			Solve a given ordinary differential equation using Euler‚Äôs method and the Runge-Kutta method.
			Additional Tips üí°
			Practice implementing different numerical methods to understand their strengths and limitations.
			Compare the accuracy of different methods by applying them to the same problem.
			Always visualize the results to gain better insights into the behavior of the solutions.
			Gotchas to Watch Out For ‚ö†Ô∏è
			Convergence: Ensure the method converges to the correct solution.
			Step Size: Choose an appropriate step size for numerical integration and differentiation.
			Initial Guess: For root-finding methods, a good initial guess is crucial for faster convergence.
			Analogies üß†
			Numerical Methods: Think of numerical methods as approximating a complex shape with simpler shapes (e.g., approximating a curve with straight lines).
			Step Size: Similar to taking small steps while walking, smaller steps lead to a more accurate path but take longer to complete.
		</textarea>
		</section>


	</div>
</div>
<script src="/dist/reveal.js"></script>
<script src="/plugin/markdown/markdown.js"></script>
<script src="/plugin/highlight/highlight.js"></script>
<script src="/plugin/notes/notes.js"></script>
<script src="/plugin/math/math.js"></script>
<script>

    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        plugins: [RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX],

        // Custom delimiters for slides, subslides, and notes
        markdown: {
            slideSeparator: '---',   // Horizontal slide separator
            verticalSeparator: '--', // Vertical slide (subslide) separator
        }
    });

</script>
</body>
</html>
